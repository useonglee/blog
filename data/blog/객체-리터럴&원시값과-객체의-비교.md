---
title: "객체 리터럴 & 원시값과 객체의 비교"
date: 2022-04-05
lastmod: "2022-04-05"
tags: ["javascript", "study"]
draft: false
summary: "모던 자바스크립트 Deep Dive 스터디 - 객체를 톺아보자!"
layout: PostSimple
type: blog
---

<TOCInline toc={props.toc} exclude="목차" toHeading={2} />

### 들어가며

현재 모던 자바스크립트 Deep Dive 책 완전 정복을 목표로 스터디를 하고 있다. 스터디 분들과 번갈아가며 맡은 내용에 대해 발표를 진행한다. 그 중에서 모던 자바스크립트 10장, 11장 발표를 맡았으며 발표 자료에 쓰기 위해 책을 읽고 정리한 글이다.<br /> (내용을 정리하며 나의 생각도 적어보았다.)

## 10장 객체 리터럴

```ts
const intro = {
  title: "객체 리터럴",
  description: "자바스크립트 객체 리터럴에 대해서 공부해보자!",
  like: 0,
  thumbsUp: function () {
    this.like++;
  },
};
```

## 10.1 객체란?

자바스크립트는 `객체(Object) 기반의 프로그래밍 언어`이며, 자바스크립트를 구성하는 거의 "모든 것"이 객체이다. 즉, 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체이다.

잠깐! 🖐 <br />

자바스크립트는 객체 기반의 프로그래밍이라고 설명했다. 그러면 과연 자바스크립트는 객체 지향 언어라고 말할 수 있을까? 보통 객체 지향 언어라고 한다면 흔히 알고 있는 자바, C++를 떠올릴 것이다. 하지만 자바스크립트는 이 둘과 다른 방식으로 객체가 생성된다. 자바스크립트 객체는 실행 시간에 빈 객체를 오버라이딩하여 메서드와 프로퍼티를 연결하는 방식으로 생성한다. 자바, C++와는 다른 방식이다. 그리고 자바스크립트는 유연한 프로그래밍을 추구하는 만큼 객체 지향 언어의 문법을 지원하면서 함수형 프로그래밍의 특징도 가지고 있다. 그렇기 때문에 객체 지향언어와 절차 지향 언어 두가지 형태로 만들 수 있다.

그리고 객체 지향 언어에서 함수는 특정한 객체나 클래스에 종속된 형태로 보지만, 자바스크립트에서 함수는 객체에 종속될 수도, 객체의 메서드가 될 수도 있다. 또는 함수 앞에 'new'를 붙여서 객체로 생성할 수도 있다. 이와 같은 형태로 자바스크립트는 유연한 언어라고 할 수 있다.

그러면 다시 돌아가서 자바스크립트는 과연 객체 지향의 언어라고 말할 수 있는가? **결론은 객체 지향 언어**는 아니다. 다만 **객체 지향 프로그래밍이 가능하다.** 이 말의 뜻은 ES6 문법인 Class를 이용해서 객체 지향 프로그래밍을 할 수 있다는 뜻이다. 그리고 애초에 자바스크립트는 객체 지향 언어로 개발되지 않았다.

<br />

다시 본문으로 돌아와서,

객체의 특징으로는 단 하나의 값만 나타내는 원시 타입의 값과 다르게 객체는 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복잡한 자료구조이다. 원시 타입의 값은 변경 불가능한 값이지만 객체는 변경 가능한 값(mutable value)이다. 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성된다.

```js
const counter = {
  num: 0, // 프로퍼티
  increase: function () {
    // 메서드
    this.num++;
  },
};
```

자바스크립트에서 **객체의 상태를 나타내는 값을 프로퍼티**라고 한다. 그리고 **그 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작**을 메서드라고 부른다. `이 프로퍼티와 메서드들의 집합이 바로 객체이다.` 그래서 객체는 프로퍼티와 메서드를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다. 책의 팁 중에서 자바스크립트의 객체와 함수는 밀접한 관계를 가진다고 한다. 그래서 책에서는 함수와 객체를 분리해서 생각할 수 없는 개념이라고 설명한다.

## 10.2 객체 리터럴에 의한 객체 생성

C++나 자바같은 클래스 기반 객체 지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자(constructor)를 호출하여 인스턴스를 생성하는 방식으로 객체를 생성한다.

> 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실체를 말한다. 객체 지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다. 클래스는 인스턴스를 생성하기 위한 템플릿 역할을 한다. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는 것에 초점을 맞춘 용어다.

그렇다면 **프로토타입 기반으로 객체를 지향하는 자바스크립트는 어떻게 객체를 생성할까?**

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

객체 생성 방법 중에서도 가장 일반적이고 간단한 방법은 객체 리터럴을 사용하는 방법이다.(객체 리터럴 이외의 방법들은 모두 함수를 사용한 객체 생성 방법이다.) 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말한다. 그러면 객체 리터럴은 어떻게 표기하는 방법일까?

객체 리터럴은 `중괄호({...})` 내에 0개 이상의 프로퍼티를 정의하는 것을 뜻한다. 즉 객체 리터럴을 사용하면 프로퍼티 값이 없어도 객체로 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성한다.

```js
const person = {
  name: "Ayaan",
  sayHello: function () {
    console.log(`Hello, My name is ${this.name}.`);
  },
};

console.log(typeof person); // object
console.log(person); // {name: "Ayaan", sayHello: ƒ}
```

객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식이다. 객체를 생성하기 위해 클래스를 먼저 정의하고 new 연산자와 함께 생성자를 호출할 필요가 없다.

## 10.3 프로퍼티

```js
const person = {
  name: "Ayaan",
  age: 29,
};
```

**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로서 식별자 역할을 한다. 그리고 프로퍼티 키는 따옴표를 사용('...')해서 문자열로 묶어야 하지만 식별자 네이밍 규칙을 준수한다면 생략할 수 있다. 하지만 반대로 식별자 네이밍 규칙을 따르지 않는다면 반드시 따옴표를 사용해야 한다.

```js
const person = {
  fistName: "Useong", // 식별자 네이밍 준수
  "last-name": "Lee", // 식별자 네이밍 준수
  nick-name: "Ayaan" // SyntaxError: Unexpected token -
};
```

따옴표가 없는 nick-name은 자바스크립트가 - 이 부분을 빼기 연산자(-)로 해석을 한다. 그렇기 때문에 문법 오류가 발생하는 것이다. 그리고 몇가지 더 재밌는 부분이 있다. 다음 코드를 보자.

```js
const foo = {
  "": "", // 빈 문자열도 프로퍼티 키로 사용 가능
  0: 0,
  1: 1,
};
```

프로퍼티 키는 빈 문자열로도 사용할 수 있다. 하지만 키로서 의미를 갖지 못하니 권장하지 않는 방법이라고 책에서 설명한다. 그리고 넘버 타입도 키로 사용할 수 있다. 하지만 자바스크립트는 내부적으로 문자열로 변환한다. 그래서 넘버 타입으로 사용해도 결국 프로퍼티 키는 문자열이 된다.

```js
const foo = {
  var: "",
  function: "",
};
```

var, function과 같이 예약어를 프로퍼티 키로 사용해도 에러가 나지 않는다. 하지만 이 부분도 예상치 못한 곳에서 에러가 날 수 있으므로 권장하지 않는다고 책에서 설명하고 있다.

```js
const foo = {
  name: "Lee",
  name: "Kim",
};

console.log(foo); // { name: 'Kim' }
```

이미 존재하는 프로퍼티 키를 중복 선언한다면 나중에 선언한 프로퍼티가 앞서 선언한 프로퍼티를 덮어 쓴다. 이 부분에서도 에러가 나지 않기 때문에 주의를 해야한다. 가장 좋은 방법은 프로퍼티 키도 변수명처럼 중복되지 않게 코드를 작성하는 것이 좋은 것 같다고 생각한다.

## 10.4 메서드

자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값으로 사용할 수 있다. 그리고 자바스크립트의 함수는 객체(일급 객체)다. 따라서 함수는 값으로 취급을 할 수 있다. 그렇다면 자바스크립트의 함수도 프로퍼티 값이 될 수 있다는 뜻이다. 함수와 메서드라는 단어를 구분짓기 위해 `프로퍼티 값으로 사용되는 함수는 메서드라고 부른다.`

```js
const 자바스크립트숙련도 = {
  level: 0, // <- 프로퍼티

  // 메서드
  studyingPlay: function () {
    return this.level++;
  },
};
```

## 10.5 프로퍼티 접근

- 마침표 표기법 (ex. person.name)
- 대괄호 표기법 (ex. person['name'])

프로퍼티 값에 접근하는 방법은 위와 같이 두가지 방법이 있다. 하지만 주의사항이 있는데, 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 그렇지 않으면 자바스크립트 엔진은 대괄호안에 있는 키를 프로퍼티 키가 아닌 식별자로 해석하기 때문에 에러가 발생한다.

```js
const person = {
  name: "Ayaan",
};

console.log(person[name]); // ReferenceError: name is not defined

console.log(person.age); // undefined
```

그리고 객체에 없는 프로퍼티 키에 접근을 하면 undefined를 반환한다. 에러가 발생하지 않는 다는 점을 주의해야 한다. 그리고 다음과 같은 에러 상황도 있다.

```js
const person = {
  "my-name": "Ayaan",
};

// person.my-name 을 실행시키면 어떻게 될까?

// ---아래와 같은 에러 발생---
// 브라우저 환경 -> NaN
// Node.js 환경 -> ReferenceError: name is not defined
```

`브라우저 환경에서는 NaN` 그리고 `Node.js 환경에서는 참조에러가 발생`한다. 이 이유는 무엇일까? person.my-name을 실행하면 자바스크립트 엔진은 먼저 person.my를 평가한다. `-`는 빼기 연산자로 해석하기 때문이다. 그러면 위 코드에서 person.my를 실행한다면 undefined를 반환할 것이다. 그래서 자바스크립트 엔진은 undefined - name 으로 평가를 하게 된다. 하지만 여기서 또 알아야 할 점은 자바스크립트에서 name은 식별자로서 전역 객체인 window를 가리키며 기본값은 빈 문자열이다. 결과적으로 undefined - ''가 된 셈이다. undefined에서 빼기 연산자를 사용했으므로 NaN을 반환하게 된 것이다.

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

```js
const [x, y] = [1, 2];

const obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}
```

ES6에서 프로퍼티 축약 표현이 추가되었다. 변수에 할당된 값을 즉시 사용할 수 있게 축약 표현이 추가된 것이다. 그리고 다음 아래와 같은 코드로도 사용이 가능하다.

```js
const [hello, world] = [1, 2];

const obj = { hello, world };

console.log(obj); // {hello: 1, world: 2}
```

변수이름(hello)와 프로퍼티 키(hello)가 같다면 프로퍼티 키를 생략할 수 있고, 프로퍼티 키는 자동으로 생성된다. 이 방법은 우리가 자주 사용하는 React에서도 사용할 수 있다.

```jsx
// app.jsx
function App() {
  const [state, setState] = useState("안녕 디지몬");

  return (
    // 기존
    <Component state={state} />

    // ES6
    <Component state />
  )
}
```

그리고 객체의 프로퍼티 키는 계산된 값을 사용해서 프로퍼티 키를 동적으로 생성할 수도 있다.

```js
const obj = {};
const prefix = "prop";
let i = 0;

obj[prefix + "-" + ++i] = i;
obj[`${prefix}-${++i}`] = i;
```

<br />
<br />

## 원시 값과 객체의 비교

자바스크립트의 타입은 원시 타입과 객체 타입으로 구분할 수 있다. 원시 타입과 객체 타입으로 구분하는 이유는 근본적으로 다르기 때문이다.
원시 타입은 변경 불가능한 값이다. 반대로 객체 타입은 변경이 가능한 값이다. 원시 값을 변수에 할당하면 메모리 공간을 확보하고 `실제 값`이 저장된다. 이에 비해 객체를 변수에 할당하면 메모리 공간에 실제 값이 아니라 `참조 값`이 저장된다.

원시 값을 변수에 할당하고 재할당을 할 경우 자바스크립트는 원본의 원시 값을 복사하여 새로운 메모리 공간에 전달된다. 이를 `값에 의한 전달`이라고 표현한다. 그렇다면 객체는 참조에 의한 전달일까? 이것은 뒤에서 더 다룰 예정이다.

## 11.1 원시 값

원시 타입은 변경 불가능한 값이라고 앞서 설명했다. 하지만 명확하게 구분지어서 이해해야 할 부분은 원시 값을 변경할 수 없다는 뜻이지 변수의 값을 변경할 수 없다는 뜻은 아니다. 변수는 메모리 공간을 확보하고 메모리 공간을 식별하기 위한 용도이다. 그렇기 때문에 재할당을 통해서 원본의 값을 복사해온 후 새로운 메모리 공간에 값을 넣고 그 변수가 참조하고 있는 값을 변경 시킬 수 있다. 하지만 값 그 자체인 원시 값은 변경할 수 없다. 즉 "원시 값은 변경할 수 없다"의 뜻은 **원시 값 자체를 변경할 수 없을 뿐이지, 변수의 값은 변경할 수 있다.**

변수의 상대 개념인 상수도 있다. 변수는 언제든 재할당을 할 수 있지만, 상수는 선언 시점에 단 한 번만 할당이 허용된다. 상수는 재할당이 금지된 변수일 뿐이다.

```js
const num = 0;
const obj = {};

num = 1;
obj.a = 1;

console.log(num); // Uncaught TypeError: Assignment to constant variable.
console.log(obj); // {a: 1}

// const 키워드를 사용하면 변수에 할당한 원시 값은 변경할 수 없다.
// 하지만 const 키워드에 할당한 객체는 변경할 수 있다.
```

<br />

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다. 그리고 더이상 참조하지 않는 메모리 공간(아래 사진에서 회색 부분)은 가비지 컬렉션에 의해 해제된다.

<center>
<img src="https://user-images.githubusercontent.com/75570915/162205951-26addf75-bd25-49c3-a728-d22b13119755.png" alt="원시값 재할당 메모리 참조 이미지" width="800" loading="lazy" />
</center>

변수 값을 변경하려면 위와 같이 재할당을 통해 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 우리는 **불변성(immutability)** 이라 한다. **불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**

## 11.1.2 문자열과 불변성

우리는 원시 값을 저장하기 위해 메모리 공간의 크기를 확보하고 결정해야 한다. 그래서 이를 위해 메모리 공간의 크기가 미리 정해져있다. 명확하게 정해져있는 것은 문자열 타입(2byte)와 숫자 타입(8byte)이다.

여기서 재미있는 사실은 숫자 값은 얼마인지에 상관없이 8byte로 결정된다. 하지만 문자열 타입은 몇 개의 문자가 있는지에 따라 메모리 공간의 크기가 결정된다.

```js
const num1 = 1; // 8byte
const num2 = 1000000; // 8byte

const str1 = "a"; // 2byte
const str2 = "ayaan"; // 10 byte
```

<br />
문자열에는 `유사 배열 객체`라는 것이 있다. 유사 배열 객체란 **마치 배열처럼 인덱스로 프로퍼터 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.** 그리고 length가 있기 때문에 for 문을 통해서 문자열의 문자들을 조회할 수 있다. 하지만 배열은 아니므로 배열의 메서드인 push, pop, shift, unshift 등은 사용할 수 없다.

```js
const name = "ayaan";

console.log(name.length); // 5
console.log(name[0]); // 'a'

for (let i = 0; i < name.length; i++) {
  console.log(name[i]); // 'a', 'y', 'a', 'a', 'n'
}
```

<br />
그렇다면, 유사 배열 객체인 문자열의 값을 수정할 수 있을까?

```js
let name = "ayaan";

name[0] = "k";

console.log(name); // undefined
```

결과는 undefined가 나왔다. 문자열은 유사 배열 객체이지만 결국 원시 값이므로 값을 변경할 수 없다. 그리고 이때 에러가 나지 않기 때문에 주의해야 한다. 이러한 문자열의 상태는 데이터의 신뢰성을 보장한다. 하지만 문자열을 재할당을 해서 변수의 값을 변경하는 것은 당연히 가능하다.

<br />

잠깐! 🖐 자바스크립트에는 또 한가지 유사 배열 객체가 있다.

또 어떤 유사 배열 객체가 있을까? 그건 바로 DOM을 조작할 때 볼 수 있다. 바로 코드를 살펴보자.

```js
<ul id="list">
  <li class="item">1</li>
  <li class="item">2</li>
  <li class="item">3</li>
  <li class="item">4</li>
  <li class="item">5</li>
  <li class="item">6</li>
  <li class="item">7</li>
  <li class="item">8</li>
  <li class="item">9</li>
  <li class="item">10</li>
</ul>;

const getAllListItems = document.querySelectorAll("#list > .item");

console.log(getAllListItems);
// NodeList(10)
// [li.item, li.item, li.item, li.item, li.item, li.item, li.item, li.item, li.item, li.item]

getAllListItems.push("li.item");
// Uncaught TypeError: getAllListItems.push is not a function
```

위에서 querySelectorAll을 통해 li tag를 전부 불러왔고, 값을 getAllListItems 변수에 할당했다. 그리고 배열 형태의 값이 저장되었다. 하지만 getAllListItems 변수에 push를 사용했을 때 에러가 난다. 분명 배열의 형태인데 왜 에러가 날까? 배열처럼 보이지만 DOM을 통해 값을 가져온 NodeList는 유사 배열 객체이다. 그래서 배열 메서드를 사용하면 에러가 난다. NodeList와 같이 배열 형태이고 유사 배열 객체일 경우에 배열 메서드를 사용하고 싶다면 Array.from, Array.slice, 스프레드 연산자 등 실제 배열로 변경한 후 배열 메서드를 사용하면 된다.

## 11.1.3 값에 의한 전달

```js
let score = 80;
let copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true

copy = 100;

console.log(score === copy); // false
```

변수(여기서는 copy)에 이미 할당된 값(여기서는 score 값)을 전달받는 것을 값에 의한 전달이라고 한다. 이때 copy는 복사된 score의 값을 전달받는 것이다. score와 copy는 같은 값을 같는건 맞지만 전혀 **다른 메모리 공간에 저장된 별개의 값이다.** 그렇기 때문에 copy의 값을 변경해도 score 변수에 전혀 영향을 주지 않는다.

<br />

<center>
<img src="https://user-images.githubusercontent.com/75570915/162218833-df42c1bc-3147-40dd-8bdf-1230cc26f2ed.png" alt="변수 값에 의한 전달 참고 이미지" width="800" loading="lazy" />
</center>

score는 copy에게 값에 의한 전달을 하지만 사실 값에 의한 전달은 자바스크립트 용어가 아니라고 책에서 설명하고 있다. 엄격하게 표현하면 **변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문**이라고 설명한다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이라고 한다. 결국 이 말의 핵심은 두 값은 서로 다른 메모리 공간에 저장된 별개의 값이라는 것이며, 재할당을 통해 한 쪽에서 값을 변경해도 서로 간섭할 수 없다는 뜻이다.
